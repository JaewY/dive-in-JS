# 14장 전역 변수의 문제점
<br>
<br>
<br>

## 14-1 변수의 생명주기

<br>

지역 변수는 함수가 호출 되었을 때만 생성되며, 함수 실행이 끝나면 지역 변수 역시 소멸한다.

```
const x = () => {
    const y = 10
    return y
}
x() // x함수가 호출된 시점에서만 y변수가 생성되고, 사라진다.
console.log(y) // undefined
```

### 즉 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.


<br>
<br>


```
const y = 5
const x = () => {
    const y = 10
    return y
}
x() // x함수가 호출된 시점에서만 y변수가 생성되고, 사라진다.
console.log(y) // 5, x함수 안의 y는 소멸되었고, 전역 변수 y가 호출되었다.
```

### 전역 변수의 생명 주기는 따로 존재하지 않는다.

---

<br>
<br>
<br>

## 14-2 전역 변수의 문제점

<br>

<br>
<li>암묵적인 결합</li>
전역 변수를 선언함은 어느 곳에서나 선언된 변수를 가져다 쓰겠다는 의미이며, 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것이다.

<br>
<li>긴 생명주기</li>
전역변수는 생명 주기가 길고, 또한 어느 코드에서나 참조하고 변경할 수 있기 때문에 var 변수 같은 경우 의도치 않은 상태 변경(재할당)이 일어날 수 있다. 

<br>
<li>스코프 체인 상에서 종점에 존재</li>
전역 변수는 스코프 체인 상에서 마지막에 존재하기 때문에 변수 검색에 있어서 가장 느리다는 단점을 가지고 있다.

<br>
<li>네임스페이스 오염</li>
자바스크립트의 큰 문제점 중 하나로, 파일이 분리되어 있다고 한들 하나의 전역 스코프를 공유한다는 것이다. 파일이 달라도 전역 변수의 이름이 동일하다면 이는 문제를 초래할 수 있다.


---
<br>
<br>
<br>

## 14-3 전역 변수의 사용을 억제하는 방법

<br>

변수의 스코프는 좁을 수록 좋으며, 가능한 한 전역 변수의 사용을 지양하고 지역 변수를 사용토록 해야 할 것이다.

<br>
<li>즉시 실행 함수</li>
모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```
(function () {
    var foo = 10
}())
```

이렇게 하면 전역변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다고 한다.

<br>
<li>네임스페이스 객체</li>

```
var MYAPP = {}
MYAPP.name = 'JANG'
```
전역 변수로 사용할 객체 하나를 만들고 그 안에 객체로 프로퍼티를 추가하여 네임 스페이스를 분리하는 방법이다.

식별자 충돌을 방지할 수는 있으나 그렇게 유용하지는 않다.

<br>
<li>모듈 패턴</li>
24장 클로저를 먼저 이해하여야 한다.
TypeScript를 공부하면 충분히 이해할 수 있는 내용이다.

<br>
<li>ES6 모듈</li>
ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공하기에 따라서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니다. 또한 window 객체의 프로퍼티도 아니다.

---
