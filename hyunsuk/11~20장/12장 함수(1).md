# 12장 함수 (1)

## 12.1 함수란?

- 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

- 함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다.

- 또한 함수는 값이며, 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.

<img width="400" alt="스크린샷 2022-09-14 오후 3 31 41" src="https://user-images.githubusercontent.com/95524491/190077074-b22e48f2-eb01-41e5-806b-ddda5a1977a8.png">

```Js
// 함수 정의
function add(x, y) {
    return x + y;
}

// 함수 호출
let result = add(2, 5);

// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.
console.log(result); // 7
```

## 12.2 함수를 사용하는 이유

- 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다.

- 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.

- 적절한 함수 이름은 함수의 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 돕는다.

- 이는 코드의 가독성을 향상시킨다.

## 12.3 함수 리터럴

- 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.

```Js
// 변수에 함수 리터럴을 할당
let f = function add(x, y) {
    return x + y;
};
```

## 12.4 함수 정의

- 함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다.

<img width="564" alt="스크린샷 2022-09-14 오후 3 43 50" src="https://user-images.githubusercontent.com/95524491/190079705-55062b16-8bfb-4590-b96e-bbdca9ad0b1f.png">

### 12.4.1 함수 선언문

- 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다

```Js
// 함수 선언문
function add(x, y) {
    return x + y;
}

// 함수 참조
console.dir(add); //  add(x, y)

// 함수 호출
console.log(add(2, 5)); // 7

// 함수 선언문은 함수 이름을 생략할 수 없다.
function (x, y) {
    return x + y;
}

// SyntaxError: Function statements require a function name
```

- 함수 선언문은 표현식이 아닌 문이다.

- 이름이 있는 기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

<img width="550" alt="스크린샷 2022-09-14 오후 4 02 31" src="https://user-images.githubusercontent.com/95524491/190084036-b5d2e9c4-298f-4664-a526-326a2055c22e.png">

### 12.4.2 함수 표현식

- 자바스크립트의 함수는 일급 객체다.

- 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.

```Js
// 함수 표현식
let add = function (x, y) {
    return x + y;
};

console.log(add(2, 5)); // 7
```

- 함수 리터럴의 함수 이름은 생략할 수 있다.

- 이러한 함수를 익명 함수라 한다.

- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

- 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없다.

```Js
// 기명 함수 표현식
let add = function foo (x, y) {
    return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

- 함수 선언문은 표현식이 아닌 문이고 함수 표현식은 표현식인 문이다.

### 12.4.3 함수 생성 시점과 함수 호이스팅

```Js
// 함수 참조
console.dir(add); //  add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
    return x + y;
}

// 함수 표현식
var sub = function (x, y) {
    return x - y;
};
```

- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.

- 함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있으므로 주의하기 바란다

- var 키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.

- 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.

- 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

### 12.4.4 Function 생성자 함수

- 자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.

- new 연산자 없이 호출해도 결과는 동일하다.

- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.

```Js
let add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```

### 12.4.5 화살표 함수

- ES6에서 도입된 화살표 함수arrow function는 function 키워드 대신 화살표 =>를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있다.

- 화살표 함수는 항상 익명 함수로 정의한다.

```Js
// 화살표 함수
const add = (x, y) => x + y;

console.log(add(2, 5)); // 7
```

- 화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

## 12.5 함수 호출

### 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.

### 12.5.1 매개변수와 인수

- 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수(parameter)(인자)를 통해 인수(argument)를 전달한다.

- 인수는 값으로 평가될 수 있는 표현식이어야 한다.

- 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.

```Js
// 함수 선언문
function add(x, y) {
    return x + y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
let result = add(1, 2);
```

- 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다.

- 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.

<img width="350" alt="스크린샷 2022-09-14 오후 4 24 03" src="https://user-images.githubusercontent.com/95524491/190088383-20817f88-f7ae-4c8e-ae9f-fcd0235403c5.png">

- 매개변수의 스코프(유효 범위)는 함수 내부다.

- 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지는 않는다.

- 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.

- 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

### 12.5.2 인수 확인

- ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.

```Js
function add(a = 0, b = 0, c = 0) {
    return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

### 12.5.3 매개변수의 최대 개수

- ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다.

- 매개변수는 순서에 의미가 있다.

- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.

- 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다

- 그 이상이 필요하다면 객체를 인수로 전달하는 것이 유리하다.

### 12.5.4 반환문

- 함수는 return 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환(return)할 수 있다.

```Js
function multiply(x, y) {
    return x * y; // 반환문
}

// 함수 호출은 반환값으로 평가된다.
let result = multiply(3, 5);
console.log(result); // 15
```

- 반환문은 두 가지 역할을 한다.

1. 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
   따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.

2. 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다.
   return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.

- 반환문은 생략할 수 있다.

- 이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.
